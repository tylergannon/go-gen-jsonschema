---
applyTo: '**'
---

# go-gen-jsonschema v1 Contract (Draft)

Status: draft
Owner: core

This document is the single source of truth for the v1 public contract: behaviors, APIs, defaults, and compatibility guarantees.

- Goals
  - Make schema generation explicit but easy to remember.
  - First‑class support for enums (including iota) and discriminated interfaces.
  - Deterministic outputs and compile‑verified codegen, including provider‑rendered schemas.
  - Maintain backwards compatibility with 0.5.3.

## Supported toolchain
- Go ≥ 1.21 (tested; CI matrix TBD); developed on Go 1.24.x.
- Module mode only.

## Terminology
- Schema method: user‑declared function/method that the tool wires to return embedded schema bytes.
- Provider: field‑level override for a property’s schema; when present, emits a .json.tmpl with holes.
- Discriminator: interface union selector property (default: "!type").

## Zero‑config defaults (convention over configuration)
- Opt‑in is explicit via NewJSONSchemaMethod / NewJSONSchemaFunc / NewJSONSchemaBuilder (see below).
- Output directory: ./jsonschema (created if missing).
- Generated code: jsonschema_gen.go in the same package.
- Build tags: generated file is excluded when the jsonschema build tag is set; embed is active when the tag is NOT set.
- Formatting/imports: code is gofmt/goimports‑clean and stable; JSON is pretty by default.
- Enum detection: named type with const block(s) is an enum; default representation = underlying values. String mode requires opt‑in (see Enums).
- Errors are explicit; the tool fails with file:line and a fix hint rather than guessing.

## Public API surface

### Primary configuration entry points

You can choose one of three equivalent ways to declare a type’s schema entry point. All three are supported in v1.

1) Method receiver (existing)

    func (T) Schema() json.RawMessage { panic("not implemented") }

    var _ = jsonschema.NewJSONSchemaMethod(T.Schema, /* options… */)

2) Free function that takes the receiver as its sole parameter (new)

    func Schema(T) json.RawMessage { panic("not implemented") }

    var _ = jsonschema.NewJSONSchemaFunc(Schema, /* options… */)

3) No‑arg builder function that returns the schema (new; common case)

    func Schema() json.RawMessage { panic("not implemented") }

    var _ = jsonschema.NewJSONSchemaBuilder(Schema, /* options… */)

Contract:
- All three forms generate the exact same embedded read‑path (jsonschema/<Type>.json or .json.tmpl) and a generated Schema() in jsonschema_gen.go that returns embedded bytes.
- Only one entry needs to be registered per type. If multiple registrations target the same type, generation fails with a clear error.
- Illegal method receivers (named types whose underlying type is pointer/interface) are skipped and reported.

### Per‑type/field options (consolidated configuration)

Attach configuration to the registration call using options:

- Enums
  - WithEnum(Owner{}.Field)               // marks the named type of the field as an enum
  - WithEnumMode(EnumStrings)             // subsequent enum is rendered as strings
  - WithEnumName(ConstValue, "name")      // optional per‑const name override

- Interfaces
  - WithInterface(Owner{}.Field)                          // discriminated interface field
  - WithInterfaceImpls(Owner{}.Field, Impl1{}, (*P)(nil)) // explicit impl set (optional)
  - WithDiscriminator(Owner{}.Field, "!kind")             // override discriminator property

- Providers (field schema overrides)
  - WithStructAccessorMethod(Owner{}.Field, (T).Method)
  - WithStructFunctionMethod(Owner{}.Field, (T).Method)        // or free func with receiver first
  - WithFunction(Owner{}.Field, FreeFunc)
  - WithRenderProviders()                                      // generate RenderedSchema() that executes providers

Legacy sentinels continue to work in v1:
- NewInterfaceImpl[T](…)
- NewEnumType[T]()

Conflict rules:
- If both legacy and new options define the same thing, generation fails with a duplicate‑config error naming both sites.

### Generated outputs and methods
- Files
  - jsonschema/<Type>.json: normal schemas.
  - jsonschema/<Type>.json.tmpl: when Providers are configured on the type; template contains {{.property}} holes.
- Methods (generated per registered type)
  - func (T) Schema() json.RawMessage
    - Always generated. Reads and returns the embedded file bytes (.json or .json.tmpl) without executing providers.
  - func (T) RenderedSchema() (json.RawMessage, error)
    - Generated only when WithRenderProviders() is present.
    - Executes provider functions, renders the .json.tmpl via text/template using a strict map[string]json.RawMessage context, and returns rendered bytes.
    - Returns error for provider MarshalJSON failures or template parse/exec failures.

Determinism:
- Outputs are deterministic functions of (AST, options, provider code, and provider results). If providers are pure for a given receiver state, rendered schemas are deterministic.

Provider placement:
- To call RenderedSchema() in normal builds, provider symbols must be compiled into the normal build (i.e., not hidden behind //go:build jsonschema).

## Enums (including iota)

Detection:
- A named type with const block(s) (with explicit values or using iota) is treated as an enum. Discovered values must be of the enum’s underlying type.

Representation modes:
- Numeric (default): JSON Schema enum is underlying values (e.g., integers). No extra (un)marshalers generated.
- String (opt‑in): add WithEnumMode(EnumStrings) after WithEnum(…). JSON Schema enum is strings.
  - Name resolution order: WithEnumName override > T.String() if present > const identifier.
  - Generated code provides MarshalJSON/UnmarshalJSON (or an owner‑side adapter) to map strings to the iota values. Unknown strings produce a clear error.
  - Names must be unique; duplicates fail generation with a diagnostic.

## Interfaces

- WithInterface marks a struct field as a discriminated interface union.
- Implementations are either discovered (package graph) or locked by WithInterfaceImpls.
- Discriminator property default is "!type" and can be overridden per field.
- We generate owner‑side UnmarshalJSON helper(s) to decode the union by discriminator.
- Restrictions (errors with file:line): interface must be the direct type of the field (not nested in parens/slices/maps); illegal placements are rejected.

## Lints and diagnostics
- Illegal receivers: underlying pointer/interface types cannot have methods; we skip generating Schema() and report the site.
- Unsupported kinds in schema mapping: maps/chans/interface placements (except allowed discriminated fields) report with position and fix advice.
- Circular types and recursion depth: clear limit and path reported.
- Providers with unknown fields or signature mismatches: precise error including the option callsite.

## Determinism
- Content address (checksum) guards writing; unchanged content keeps file mtimes stable.
- Pretty JSON enabled by default; trailing newline enforced.
- Code formatted and imports fixed.

## CLI
- go:generate friendly: a minimal gen/main.go that calls internal/builder.Run with no flags is sufficient.
- Optional commands (future/cobra): init, check, fix, doctor. Not required for v1 contract.

## Backward compatibility
- v0.5.x API remains available in v1: NewJSONSchemaMethod (existing), NewInterfaceImpl, NewEnumType.
- New NewJSONSchemaFunc and NewJSONSchemaBuilder are additive.

## Examples

Method form with consolidated options and provider rendering:

    type Fancy struct { Color Color `json:"color"`; IFace TestInterface `json:"iface"` }

    func (Fancy) Schema() json.RawMessage { panic("not implemented") }

    var _ = jsonschema.NewJSONSchemaMethod(
      Fancy.Schema,
      jsonschema.WithEnum(Fancy{}.Color),
      jsonschema.WithEnumMode(jsonschema.EnumStrings),
      jsonschema.WithInterface(Fancy{}.IFace),
      jsonschema.WithRenderProviders(),
    )

Free‑function form:

    func FancySchema(Fancy) json.RawMessage { panic("not implemented") }
    var _ = jsonschema.NewJSONSchemaFunc(
      FancySchema,
      jsonschema.WithEnum(Fancy{}.Color),
    )

Builder (no‑arg) form:

    func FancySchema() json.RawMessage { panic("not implemented") }
    var _ = jsonschema.NewJSONSchemaBuilder(
      FancySchema,
      jsonschema.WithInterface(Fancy{}.IFace),
    )

## Open questions / decisions to make
- Enum string mode adapters: attach (un)marshalers to the enum type vs. owner‑side adapter only. Default proposal: attach to the enum type if local and writable; otherwise owner‑side adapter.
- CLI surface (cobra) and completions timing.
- Global discriminator default override (package‑level vs. per‑field only).
