// Code generated by github.com/tylergannon/go-gen-jsonschema; DO NOT EDIT.
package testapp3validate

import (
	"bytes"
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"io/fs"

	jsonschema "github.com/santhosh-tekuri/jsonschema"
	llmfriendlytimepkg3 "github.com/tylergannon/go-gen-jsonschema-testapp/llmfriendlytimepkg3"
)

//go:embed jsonschema
var __jsonschemaImports embed.FS

func (MovieCharacter) Schema() ([]byte, error) {
	return __jsonschemaImports.ReadFile("jsonschema/MovieCharacter.json")
}

var errNoDiscriminator = errors.New("no discriminator __type__ provided")

var schemaValidatorForMovieCharacter *jsonschema.Schema

func (it *MovieCharacter) UnmarshalJSON(data []byte) error {
	var err error
	if schemaValidatorForMovieCharacter == nil {
		if schemaValidatorForMovieCharacter, err = loadSchema("jsonschema/MovieCharacter.json"); err != nil {
			return err
		}
	}
	if err = schemaValidatorForMovieCharacter.Validate(bytes.NewReader(data)); err != nil {
		return fmt.Errorf("validation error: %w", err)
	}
	type Alias MovieCharacter
	var temp Alias
	if err = json.Unmarshal(data, &temp); err != nil {
		return err
	}
	*it = MovieCharacter(temp)
	return nil
}

var _ json.Unmarshaler = (*MovieCharacter)(nil)

func (it *LLMFriendlyTime) UnmarshalJSON(data []byte) error {
	var (
		temp          map[string]json.RawMessage
		err           error
		discriminator string
	)

	if err = json.Unmarshal(data, &temp); err != nil {
		return fmt.Errorf("data does not conform to map[string]json.RawMessage: %w", err)
	}
	if discTemp, ok := temp["__type__"]; !ok {
		return errNoDiscriminator
	} else {
		if err = json.Unmarshal(discTemp, &discriminator); err != nil {
			return fmt.Errorf("discriminator value is not a string: %w", err)
		}
	}
	switch discriminator {

	case "TimeAgo":
		var __TimeAgo llmfriendlytimepkg3.TimeAgo
		err = json.Unmarshal(data, &__TimeAgo)
		if err != nil {
			return fmt.Errorf("unmarshaling TimeAgo: %w", err)
		}
		*it, err = TimeAgoToLLMFriendlyTime(__TimeAgo)

	case "TimeFromNow":
		var __TimeFromNow llmfriendlytimepkg3.TimeFromNow
		err = json.Unmarshal(data, &__TimeFromNow)
		if err != nil {
			return fmt.Errorf("unmarshaling TimeFromNow: %w", err)
		}
		*it, err = FromNowToLLMFriendlyTime(__TimeFromNow)

	case "ActualTime":
		var __ActualTime llmfriendlytimepkg3.ActualTime
		err = json.Unmarshal(data, &__ActualTime)
		if err != nil {
			return fmt.Errorf("unmarshaling ActualTime: %w", err)
		}
		*it, err = ActualTimeToLLMFriendlyTime(__ActualTime)

	case "Now":
		var __Now llmfriendlytimepkg3.Now
		err = json.Unmarshal(data, &__Now)
		if err != nil {
			return fmt.Errorf("unmarshaling Now: %w", err)
		}
		*it, err = NowToLLMFriendlyTime(__Now)

	case "BeginningOfTime":
		var __BeginningOfTime llmfriendlytimepkg3.BeginningOfTime
		err = json.Unmarshal(data, &__BeginningOfTime)
		if err != nil {
			return fmt.Errorf("unmarshaling BeginningOfTime: %w", err)
		}
		*it, err = BeginningOfTimeToLLMFriendlyTime(__BeginningOfTime)

	case "NearestDay":
		var __NearestDay llmfriendlytimepkg3.NearestDay
		err = json.Unmarshal(data, &__NearestDay)
		if err != nil {
			return fmt.Errorf("unmarshaling NearestDay: %w", err)
		}
		*it, err = NearestDayToTime(__NearestDay)

	case "NearestDate":
		var __NearestDate llmfriendlytimepkg3.NearestDate
		err = json.Unmarshal(data, &__NearestDate)
		if err != nil {
			return fmt.Errorf("unmarshaling NearestDate: %w", err)
		}
		*it, err = NearestDateToTime(__NearestDate)

	default:
		return fmt.Errorf("unknown discriminator %s", discriminator)
	}

	return err
}

var _ json.Unmarshaler = (*LLMFriendlyTime)(nil)

// loadSchema loads and compiles a json schema from the generated json schema
// located at filePath, for use in validating schema prior to unmarshaling.
func loadSchema(filePath string) (*jsonschema.Schema, error) {
	var (
		schemaBytes fs.File
		compiler    = jsonschema.NewCompiler()
		schema      *jsonschema.Schema
		err         error
	)
	if schemaBytes, err = __jsonschemaImports.Open(filePath); err != nil {
		return nil, fmt.Errorf("loading schema document %s: %w", filePath, err)
	} else if err = compiler.AddResource(filePath, schemaBytes); err != nil {
		return nil, fmt.Errorf("adding schema resource for file %s: %w", filePath, err)
	} else if schema, err = compiler.Compile(filePath); err != nil {
		return nil, fmt.Errorf("compiling schema for file %s: %w", filePath, err)
	}
	return schema, nil
}
