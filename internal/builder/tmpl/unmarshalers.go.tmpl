// Code generated by github.com/tylergannon/go-gen-jsonschema; DO NOT EDIT.
{{/* gotype:github.com/tylergannon/go-gen-jsonschema/internal/builder.UnmarshalerBuilder*/ -}}

package {{ .ImportMap.LocalPkgName }}

import (
	"bytes"
    "encoding/json"
    "errors"
    "fmt"
	{{- if not .UnmarshalersOnly }}
	"embed"
	"io/fs"
	{{ end }}

{{ range .ImportMap.ImportStatements }}
    {{ . }}
    {{- end -}}
)
{{ $validate := .Validate }}
{{ $schemaDir := .SchemaDir -}}
{{ $discProp := .DiscriminatorPropName -}}

{{- if not .UnmarshalersOnly }}
//go:embed {{.SchemaDir}}
var __jsonschemaImports embed.FS
{{ range .TypeNames }}
func ({{.}}) Schema() ([]byte, error) {
	return __jsonschemaImports.ReadFile("{{ $schemaDir }}/{{.}}.json")
}
{{ end }}
{{ end -}}

{{ $jsonSchemaPrefix := .JSONSchemaPrefix -}}
{{ if .HaveAlts }}
var errNoDiscriminator = errors.New("no discriminator {{$discProp}} provided")
{{ end }}
{{ if .Validate }}
{{ range .TypesWithoutAlts }}

var schemaValidatorFor{{.}}      *{{$jsonSchemaPrefix}}.Schema

func (it *{{.}}) UnmarshalJSON(data []byte) error {
	var err error
	if schemaValidatorFor{{.}} == nil {
		if schemaValidatorFor{{.}}, err = loadSchema("{{ $schemaDir }}/{{.}}.json"); err != nil {
			return err
		}
	}
	if err = schemaValidatorFor{{.}}.Validate(bytes.NewReader(data)); err != nil {
		return fmt.Errorf("validation error: %w", err)
	}
	type Alias {{.}}
	var temp Alias
	if err = json.Unmarshal(data, &temp); err != nil {
		return err
	}
	*it = {{.}}(temp)
	return nil
}

var _ json.Unmarshaler = (*{{.}})(nil)
{{ end }}
{{ end }}
{{ range .TypesWithAlts }}

{{ if and $validate .HasSchema }}
var schemaValidatorFor{{.TypeName}}      *{{$jsonSchemaPrefix}}.Schema
{{ end }}
func (it *{{.TypeName}}) UnmarshalJSON(data []byte) error {
	var (
		temp map[string]json.RawMessage
		err error
		discriminator string
	)
	{{if and $validate .HasSchema}}
	if schemaValidatorFor{{.TypeName}} == nil {
		if schemaValidatorFor{{.TypeName}}, err = loadSchema("{{ $schemaDir }}/{{.TypeName}}.json"); err != nil {
			return err
		}
	}
	if err = schemaValidatorFor{{.TypeName}}.Validate(bytes.NewReader(data)); err != nil {
		return fmt.Errorf("validation error: %w", err)
	}
	{{end}}
	if err = json.Unmarshal(data, &temp); err != nil {
		return fmt.Errorf("data does not conform to map[string]json.RawMessage: %w", err)
    }
	if discTemp, ok := temp["{{$discProp}}"]; !ok {
		return errNoDiscriminator
    } else {
		if err = json.Unmarshal(discTemp, &discriminator); err != nil {
			return fmt.Errorf("discriminator value is not a string: %w", err)
		}
    }
    switch discriminator {
	{{ range .Alts }}
    case "{{.Discriminator}}":
		var __{{.Discriminator}} {{ .TypeName }}
		err = json.Unmarshal(data, &__{{.Discriminator}})
		if err != nil {
			return fmt.Errorf("unmarshaling {{.Discriminator}}: %w", err)
        }
		*it, err = {{.ConversionFunc}}(__{{.Discriminator}})
	{{ end }}
    default:
	    return fmt.Errorf("unknown discriminator %s", discriminator)
    }

    return err
}

var _ json.Unmarshaler = (*{{.TypeName}})(nil)
{{ end }}
{{ if .Validate }}

// loadSchema loads and compiles a json schema from the generated json schema
// located at filePath, for use in validating schema prior to unmarshaling.
func loadSchema(filePath string) (*{{.JSONSchemaPrefix}}.Schema, error) {
	var (
		schemaBytes fs.File
		compiler    = {{.JSONSchemaPrefix}}.NewCompiler()
	schema      *{{.JSONSchemaPrefix}}.Schema
	err         error
	)
	if schemaBytes, err = __jsonschemaImports.Open(filePath); err != nil {
		return nil, fmt.Errorf("loading schema document %s: %w", filePath, err)
	} else if err = compiler.AddResource(filePath, schemaBytes); err != nil {
		return nil, fmt.Errorf("adding schema resource for file %s: %w", filePath, err)
	} else if schema, err = compiler.Compile(filePath); err != nil {
		return nil, fmt.Errorf("compiling schema for file %s: %w", filePath, err)
	}
	return schema, nil
}
{{end}}