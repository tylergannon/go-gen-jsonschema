{{/* gotype:github.com/tylergannon/go-gen-jsonschema/internal/builder.SchemaBuilder*/ -}}
// Code generated by go-gen-jsonschema. DO NOT EDIT.
//go:build !{{.BuildTag}}
// +build !{{.BuildTag}}
package {{.Scan.Pkg.Name}}

import (
    "embed"
    "encoding/json"
	"errors"
    "fmt"
	{{- if gt (len .RenderedTypes) 0 }}
	"bytes"
	"text/template"
	{{- end }}
	{{ range .Imports}}
	{{.}}
	{{ end -}}
)
{{ $subdir := .Subdir -}}
{{ $discriminatorProp := .DiscriminatorProp}}
//go:embed {{$subdir}}
var __gen_jsonschema_fs embed.FS

var errNoDiscriminator = errors.New("no discriminator property '{{$discriminatorProp}}' found")

func __gen_jsonschema_panic(fname string, err error) {
	panic(fmt.Sprintf("error reading %s from embedded FS: %s", fname, err.Error()))
}


{{ range .SchemaMethods }}
{{/* If providers exist, name the receiver to call helper; else keep prior signature shape */}}
    {{ $recvName := .Receiver.TypeName -}}
    {{ $methName := .SchemaMethodName -}}
    {{ $found := false -}}
    {{ range $.TypeProviders }}
        {{ if and (eq .TypeName $recvName) (gt (len .Providers) 0) }}
            {{ $found = true -}}
        {{ end }}
    {{ end }}
    {{ if $found -}}
func ({{if .IsPointer}}*{{end}}{{.Receiver.TypeName}}) {{.SchemaMethodName}}() json.RawMessage {
	const fileName = "{{$subdir}}/{{.Receiver.TypeName}}.json.tmpl"
    data, err := __gen_jsonschema_fs.ReadFile(fileName)
    if err != nil {
        __gen_jsonschema_panic(fileName, err)
    }
    return data
}
    {{ else -}}
func ({{if .IsPointer}}*{{end}}{{.Receiver.TypeName}}) {{.SchemaMethodName}}() json.RawMessage {
	const fileName = "{{$subdir}}/{{.Receiver.TypeName}}.json"
	data, err := __gen_jsonschema_fs.ReadFile(fileName)
	if err != nil {
		__gen_jsonschema_panic(fileName, err)
    }
	return data
}
    {{ end -}}
{{ end -}}

{{ range .SpecialTypes -}}
{{$initial := .Initial -}}
// UnmarshalJSON is a generated custom json.Unmarshaler implementation for
// {{.Name}}.
func ({{.Initial}} *{{.Name}}) UnmarshalJSON(b []byte) (err error) {
	type Alias {{.Name}}
	type Wrapper struct {
		Alias
		{{range .InterfaceProps -}}
		{{.FieldNames}} json.RawMessage {{.StructTag}}
		{{ end -}}
	}
	var wrapper Wrapper
	if err = json.Unmarshal(b, &wrapper); err != nil {
		return err
	}
	*{{.Initial}} = {{.Name}}(wrapper.Alias)
	{{range $i, $prop := .InterfaceProps -}}
	{{if eq $i 0}}if{{else}} else if{{end}} {{$initial}}.{{$prop.FieldNames}}, err = {{$prop.UnmarshalerFunc}}(wrapper.{{$prop.FieldNames}}); err != nil {
		return err
	}{{end}}
	return nil
}
{{ end -}}
{{ range .Interfaces -}}
func {{.UnmarshalerFunc}}(data []byte) ({{.TypeNameWithPrefix}}, error) {
	var (
		temp          map[string]json.RawMessage
		discriminator string
		err         = json.Unmarshal(data, &temp)
	)

	if err != nil {
		return nil, err
	} else if _tempDiscriminator, ok := temp["{{$discriminatorProp}}"]; !ok {
		return nil, errNoDiscriminator
	} else if err = json.Unmarshal(_tempDiscriminator, &discriminator); err != nil {
		return nil, __jsonschema__unmarshalDiscriminatorError(_tempDiscriminator, err)
	}
	switch discriminator {
	{{range .Options -}}
	case "{{.Discriminator}}":
		var obj {{.TypeNameWithPrefix}}
		if err = json.Unmarshal(data, &obj); err != nil {
			return nil, err
		}
		return {{if .Pointer}}&{{end}}obj, nil
	{{ end -}}
	default:
		return nil, fmt.Errorf("unknown discriminator: %s", discriminator)
	}
}
{{ end }}
{{ if .HaveInterfaces -}}
 func __jsonschema__unmarshalDiscriminatorError(discriminator json.RawMessage, err error) error {
 	return fmt.Errorf("unable to unmarshal discriminator value %v: %w", discriminator, err)
 }
 {{ end -}}

{{/* Generate RenderedSchema() for types that requested it */}}
{{ range .SchemaMethods -}}
{{ $recv := .Receiver.TypeName -}}
{{ if index $.Rendered $recv -}}
func (t {{if .IsPointer}}*{{end}}{{.Receiver.TypeName}}) RenderedSchema() (json.RawMessage, error) {
	const fileName = "{{$subdir}}/{{.Receiver.TypeName}}.json.tmpl"
	data, err := __gen_jsonschema_fs.ReadFile(fileName)
	if err != nil { __gen_jsonschema_panic(fileName, err) }
	ctx := map[string]json.RawMessage{}
	{{ range $.TypeProviders -}}
		{{ if eq .TypeName $recv -}}
			{{ range .Providers -}}
			// provider for {{.FieldName}}
			{
				var __prov json.Marshaler
				{{- if .ProviderIsMethod }}
					{{- if eq .Kind "WithStructAccessorMethod" }}
				__prov = t.{{.ProviderName}}()
					{{- else if eq .Kind "WithStructFunctionMethod" }}
				__prov = t.{{.ProviderName}}(t.{{.FieldName}})
					{{- end }}
				{{- else }}
					{{- if eq .Kind "WithFunction" }}
				__prov = {{.ProviderName}}(t.{{.FieldName}})
					{{- end }}
				{{- end }}
				__b, __err := __prov.MarshalJSON()
				if __err != nil { return nil, __err }
				ctx["{{.JSONName}}"] = json.RawMessage(__b)
			}
			{{ end -}}
		{{ end -}}
	{{ end -}}
	tpl, err := template.New("schema").Option("missingkey=error").Parse(string(data))
	if err != nil { return nil, err }
	var buf bytes.Buffer
	if err := tpl.Execute(&buf, ctx); err != nil { return nil, err }
	return json.RawMessage(buf.Bytes()), nil
}
{{ end -}}
{{ end -}}
