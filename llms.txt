# go-gen-jsonschema

A Go code generator that creates JSON Schema definitions from Go types. This tool analyzes your Go structs, interfaces, and enums to automatically generate corresponding JSON Schema files that can be used for validation, documentation, and API contracts.

## Key Features

- **Automatic Schema Generation**: Generates JSON Schema from Go structs with support for nested types, arrays, and pointers
- **Enum Support**: Auto-discovers and handles both string and integer (iota) enums
- **Interface/Union Types**: Supports interface-based union types with discriminators
- **Type Comments**: Preserves Go comments as JSON Schema descriptions
- **Template Providers**: Support for runtime schema customization via template rendering
- **Build Tag Separation**: Keeps schema registration separate from production code using build tags

## Installation

Install the CLI tool:
```bash
go install github.com/tylergannon/go-gen-jsonschema/gen-jsonschema@latest
```

## Basic Usage

### Step 1: Add Generate Directive

Add a `//go:generate` directive to your types file:

```go
// types.go
package mypackage

//go:generate gen-jsonschema

// Or if not installed globally:
//go:generate go run github.com/tylergannon/go-gen-jsonschema/gen-jsonschema

type Person struct {
    // Name is the person's full name
    Name string `json:"name"`
    
    // Age in years
    Age int `json:"age"`
    
    // Email address (optional)
    Email string `json:"email,omitempty"`
}
```

### Step 2: Create Schema Registration File

Create a `schema.go` file with the `jsonschema` build tag:

```go
// schema.go
//go:build jsonschema

package mypackage

import (
    "encoding/json"
    jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

// Schema method stub - will be implemented by code generation
func (Person) Schema() json.RawMessage { 
    panic("not implemented") 
}

// Register the type for schema generation
var _ = jsonschema.NewJSONSchemaMethod(Person.Schema)
```

### Step 3: Generate Schemas

Run the generator:
```bash
go generate ./...
```

This creates:
- `jsonschema/Person.json` - The JSON Schema file
- `jsonschema_gen.go` - Generated code implementing the Schema() method

## Complete Examples

### Example 1: Basic Struct with Nested Types

```go
// types.go
package store

//go:generate gen-jsonschema

// Address represents a physical address
type Address struct {
    // Street address including number
    Street string `json:"street"`
    
    // City name
    City string `json:"city"`
    
    // State or province
    State string `json:"state"`
    
    // Postal/ZIP code
    PostalCode string `json:"postalCode"`
}

// Customer represents a store customer
type Customer struct {
    // Unique customer ID
    ID string `json:"id"`
    
    // Customer's full name
    Name string `json:"name"`
    
    // Customer's primary address
    Address Address `json:"address"`
    
    // Additional addresses (optional)
    OtherAddresses []Address `json:"otherAddresses,omitempty"`
    
    // VIP status
    IsVIP bool `json:"isVip"`
}
```

```go
// schema.go
//go:build jsonschema

package store

import (
    "encoding/json"
    jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Address) Schema() json.RawMessage { panic("not implemented") }
func (Customer) Schema() json.RawMessage { panic("not implemented") }

var (
    _ = jsonschema.NewJSONSchemaMethod(Address.Schema)
    _ = jsonschema.NewJSONSchemaMethod(Customer.Schema)
)
```

Generated `jsonschema/Customer.json`:
```json
{
  "type": "object",
  "description": "Customer represents a store customer",
  "properties": {
    "id": {
      "type": "string",
      "description": "Unique customer ID"
    },
    "name": {
      "type": "string",
      "description": "Customer's full name"
    },
    "address": {
      "$ref": "#/definitions/Address",
      "description": "Customer's primary address"
    },
    "otherAddresses": {
      "type": "array",
      "description": "Additional addresses (optional)",
      "items": {
        "$ref": "#/definitions/Address"
      }
    },
    "isVip": {
      "type": "boolean",
      "description": "VIP status"
    }
  },
  "required": ["id", "name", "address", "isVip"],
  "additionalProperties": false
}
```

### Example 2: String Enums with Auto-Discovery

```go
// types.go
package tasks

//go:generate gen-jsonschema

// Status represents the state of a task
type Status string

const (
    // Task is waiting to be started
    StatusPending Status = "pending"
    // Task is currently being worked on
    StatusInProgress Status = "in_progress"
    // Task has been completed
    StatusCompleted Status = "completed"
    // Task has been cancelled
    StatusCancelled Status = "cancelled"
)

// Priority represents task importance
type Priority string

const (
    PriorityLow    Priority = "low"
    PriorityMedium Priority = "medium"
    PriorityHigh   Priority = "high"
)

// Task represents a work item
type Task struct {
    // Unique task identifier
    ID string `json:"id"`
    
    // Task title
    Title string `json:"title"`
    
    // Current status
    Status Status `json:"status"`
    
    // Task priority
    Priority Priority `json:"priority"`
}
```

```go
// schema.go
//go:build jsonschema

package tasks

import (
    "encoding/json"
    jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Task) Schema() json.RawMessage { panic("not implemented") }

// WithEnum auto-discovers the enum type - no NewEnumType needed!
var _ = jsonschema.NewJSONSchemaMethod(
    Task.Schema,
    jsonschema.WithEnum(Task{}.Status),
    jsonschema.WithEnum(Task{}.Priority),
)
```

Generated schema includes enum values with descriptions from comments.

### Example 3: Integer (iota) Enums with Stringer

```go
// types.go
package logging

//go:generate gen-jsonschema

import "fmt"

// LogLevel represents the severity of log messages
type LogLevel int

const (
    // Detailed diagnostic information
    LogDebug LogLevel = iota
    // General informational messages
    LogInfo
    // Warning messages
    LogWarning
    // Error messages
    LogError
    // Fatal errors that cause termination
    LogFatal
)

// String implements the Stringer interface
func (l LogLevel) String() string {
    return [...]string{"DEBUG", "INFO", "WARNING", "ERROR", "FATAL"}[l]
}

// Config represents application configuration
type Config struct {
    // Application name
    AppName string `json:"appName"`
    
    // Minimum log level to record
    LogLevel LogLevel `json:"logLevel"`
}
```

```go
// schema.go
//go:build jsonschema

package logging

import (
    "encoding/json"
    jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Config) Schema() json.RawMessage { panic("not implemented") }

var _ = jsonschema.NewJSONSchemaMethod(
    Config.Schema,
    // Use WithStringerEnum to use constant names instead of integer values
    jsonschema.WithStringerEnum(Config{}.LogLevel),
)
```

With `WithStringerEnum`, the schema will use string enum values: ["LogDebug", "LogInfo", ...].
Without it (using `WithEnum`), it uses integer values: [0, 1, 2, 3, 4].

### Example 4: Interface-Based Union Types

**Note:** Arrays of interfaces (e.g., `[]PaymentMethod`) are not currently supported. Use a single interface field instead.

```go
// types.go
package payments

//go:generate gen-jsonschema

// PaymentMethod is an interface for different payment types
type PaymentMethod interface {
    Validate() error
}

// CreditCard payment method
type CreditCard struct {
    // Card number (masked)
    Number string `json:"number"`
    // Cardholder name
    Name string `json:"name"`
    // Expiry in MM/YY format
    Expiry string `json:"expiry"`
}

func (c CreditCard) Validate() error { return nil }

// BankTransfer payment method
type BankTransfer struct {
    // Bank account number
    AccountNumber string `json:"accountNumber"`
    // Routing number
    RoutingNumber string `json:"routingNumber"`
}

func (b BankTransfer) Validate() error { return nil }

// Payment represents a payment transaction
type Payment struct {
    // Payment ID
    ID string `json:"id"`
    
    // Payment amount in cents
    Amount int64 `json:"amount"`
    
    // Payment method used
    Method PaymentMethod `json:"method"`
}
```

```go
// schema.go
//go:build jsonschema

package payments

import (
    "encoding/json"
    jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Payment) Schema() json.RawMessage { panic("not implemented") }
func (CreditCard) Schema() json.RawMessage { panic("not implemented") }
func (BankTransfer) Schema() json.RawMessage { panic("not implemented") }

var (
    _ = jsonschema.NewJSONSchemaMethod(Payment.Schema)
    _ = jsonschema.NewJSONSchemaMethod(CreditCard.Schema)
    _ = jsonschema.NewJSONSchemaMethod(BankTransfer.Schema)
    
    // Register interface implementations
    _ = jsonschema.NewInterfaceImpl[PaymentMethod](
        CreditCard{},
        BankTransfer{},
    )
)
```

### Example 5: Template Providers for Runtime Customization

```go
// types.go
package api

//go:generate gen-jsonschema

import "encoding/json"

// Config with runtime-provided schemas
type Config struct {
    Name string `json:"name"`
    Port int    `json:"port"`
    TLS  bool   `json:"tls"`
}

// Provider methods must be in types.go (not behind build tags)
// so they're available at runtime for RenderedSchema()
func (Config) NameSchema() json.Marshaler {
    return json.RawMessage(`{"type":"string","minLength":1,"maxLength":100}`)
}

func (Config) PortSchema(_ int) json.Marshaler {
    return json.RawMessage(`{"type":"integer","minimum":1,"maximum":65535}`)
}

func BoolSchema(_ bool) json.Marshaler {
    return json.RawMessage(`{"type":"boolean","description":"Enable TLS"}`)
}
```

```go
// schema.go
//go:build jsonschema

package api

import (
    "encoding/json"
    jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Config) Schema() json.RawMessage { panic("not implemented") }

var _ = jsonschema.NewJSONSchemaMethod(
    Config.Schema,
    jsonschema.WithStructAccessorMethod(Config{}.Name, (Config).NameSchema),
    jsonschema.WithStructFunctionMethod(Config{}.Port, (Config).PortSchema),
    jsonschema.WithFunction(Config{}.TLS, BoolSchema),
    jsonschema.WithRenderProviders(), // Enables runtime template rendering
)
```

This generates:
- `jsonschema/Config.json.tmpl` - Template file with {{.name}}, {{.port}}, {{.tls}} placeholders
- `(Config) Schema()` - Returns the raw template
- `(Config) RenderedSchema()` - Executes providers at runtime and renders the template

## Known Limitations

1. **Map Types**: Not supported in type definitions or struct fields
   ```go
   type MyMap map[string]string // NOT SUPPORTED
   type Struct struct {
       Fields map[string]any `json:"fields"` // NOT SUPPORTED
   }
   ```

2. **Circular/Recursive References**: Not supported
   ```go
   type Node struct {
       Children []Node `json:"children"` // NOT SUPPORTED - circular reference
   }
   ```

3. **External Package Types**: Most external types not supported except:
   - `time.Time` is automatically handled as a string with RFC3339 format guidance
   ```go
   type Event struct {
       When time.Time `json:"when"` // Automatically generates string with RFC3339 description
   }
   ```
   The generated schema will include description: "RFC3339 formatted date-time string (e.g., \"2006-01-02T15:04:05Z07:00\")"
   
4. **Arrays of Interfaces**: Not supported
   ```go
   type Container struct {
       Items []MyInterface `json:"items"` // NOT SUPPORTED
       // Workaround: Use single interface field instead
       Item MyInterface `json:"item"` // SUPPORTED
   }
   ```

## Build and Test

```bash
# Generate all schemas
go generate ./...

# Build (excluding schema registration code)
go build ./...

# Build with schema registration (for testing)
go build -tags=jsonschema ./...

# Run tests
go test ./...
```

## Project Structure

```
myproject/
├── types.go              # Your Go types with //go:generate directive
├── schema.go             # Schema registration (build tag: jsonschema)
├── jsonschema/          # Generated JSON Schema files (created by tool)
│   ├── Person.json
│   └── Task.json
└── jsonschema_gen.go    # Generated implementation (created by tool)
```

## API Reference

### Registration Functions

- `NewJSONSchemaMethod(method, ...options)` - Register a type with a Schema() method
- `NewJSONSchemaFunc(func, ...options)` - Register with a free function that takes receiver
- `NewJSONSchemaBuilder[T](builder, ...options)` - Register with a no-arg builder function
- `NewInterfaceImpl[T](implementations...)` - Register interface implementations
- `NewEnumType[T]()` - Register an enum type (though WithEnum is preferred)

### Options

- `WithEnum(field)` - Auto-discover and configure enum field (string or int)
- `WithStringerEnum(field)` - Use string representation for integer enums with Stringer
- `WithInterface(field)` - Configure interface field
- `WithInterfaceImpls(field, ...impls)` - Specify interface implementations
- `WithDiscriminator(field, property)` - Set discriminator property for unions
- `WithRenderProviders()` - Enable runtime template rendering

### Provider Options

- `WithFunction(field, func)` - Map field to provider function
- `WithStructAccessorMethod(field, method)` - Map field to accessor method
- `WithStructFunctionMethod(field, method)` - Map field to function method

## Debugging

If generation fails:
1. Check that all types in schema.go are defined in types.go
2. Ensure build tags are correct (`//go:build jsonschema`)
3. Verify that circular references are avoided
4. For enums, use WithEnum for auto-discovery instead of NewEnumType