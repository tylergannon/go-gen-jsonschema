# Complete Guide: go-gen-jsonschema for AI Coding Assistants

## What This Tool Does
Generates JSON Schema files from Go type definitions, perfect for LLM function calling (OpenAI, Anthropic, etc).
The generated schemas are embedded in your Go binary for runtime access.

## Installation & Usage

### Install the CLI tool:
```bash
go install github.com/tylergannon/go-gen-jsonschema/gen-jsonschema@latest
```

### Command to generate schemas:
```bash
# Run in directory with schema.go files
go run github.com/tylergannon/go-gen-jsonschema/gen-jsonschema --pretty

# Or with go generate
//go:generate go run github.com/tylergannon/go-gen-jsonschema/gen-jsonschema --pretty
```

## Complete Working Example 1: Basic Types

### Step 1: Create types.go
```go
package myapp

// Person represents a person with contact info
type Person struct {
	// Full name of the person
	Name string `json:"name"`
	
	// Age in years
	Age int `json:"age"`
	
	// Email address (optional field)
	Email string `json:"email,omitempty" jsonschema:"optional"`
	
	// Phone number
	Phone string `json:"phone" jsonschema:"optional" description:"Contact phone number"`
}

// Team represents a group of people
type Team struct {
	TeamName string   `json:"team_name"`
	Members  []Person `json:"members"`
	LeadID   int      `json:"lead_id"`
}
```

### Step 2: Create schema.go
```go
//go:build jsonschema
// +build jsonschema

package myapp

import (
	"encoding/json"
	jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

// Schema method stubs (will be replaced by generator)
func (Person) Schema() json.RawMessage { panic("not implemented") }
func (Team) Schema() json.RawMessage   { panic("not implemented") }

// Register types for schema generation
var (
	_ = jsonschema.NewJSONSchemaMethod(Person.Schema)
	_ = jsonschema.NewJSONSchemaMethod(Team.Schema)
)
```

### Step 3: Generate
```bash
go run github.com/tylergannon/go-gen-jsonschema/gen-jsonschema --pretty
```

### Step 4: Results
Creates:
- `jsonschema/Person.json` - JSON schema for Person
- `jsonschema/Team.json` - JSON schema for Team
- `jsonschema_gen.go` - Go code to access schemas at runtime

## Complete Working Example 2: Enums

### types.go
```go
package myapp

// Status represents task status
type Status string

const (
	StatusPending  Status = "pending"
	StatusActive   Status = "active"
	StatusComplete Status = "complete"
	StatusCanceled Status = "canceled"
)

// Priority level for tasks
type Priority int

const (
	PriorityLow Priority = iota
	PriorityMedium
	PriorityHigh
	PriorityUrgent
)

// Task with enum fields
type Task struct {
	Title    string   `json:"title"`
	Status   Status   `json:"status"`
	Priority Priority `json:"priority"`
}
```

### schema.go
```go
//go:build jsonschema
// +build jsonschema

package myapp

import (
	"encoding/json"
	jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Task) Schema() json.RawMessage { panic("not implemented") }

var (
	_ = jsonschema.NewJSONSchemaMethod(Task.Schema)
	
	// Register string enum (uses const values)
	_ = jsonschema.NewEnumType[Status]()
	
	// Register int enum  
	_ = jsonschema.NewEnumType[Priority]()
)
```

## Complete Working Example 3: Union Types (Interfaces)

### types.go
```go
package myapp

// PaymentMethod is implemented by different payment types
type PaymentMethod interface {
	isPaymentMethod()
}

// CreditCard payment
type CreditCard struct {
	CardNumber string `json:"card_number"`
	CVV        string `json:"cvv"`
}

func (CreditCard) isPaymentMethod() {}

// BankTransfer payment
type BankTransfer struct {
	AccountNum string `json:"account_num"`
	RoutingNum string `json:"routing_num"`
}

func (BankTransfer) isPaymentMethod() {}

// PayPal payment (note: pointer receiver)
type PayPal struct {
	Email string `json:"email"`
}

func (*PayPal) isPaymentMethod() {}

// Order with polymorphic payment field
type Order struct {
	ID      string        `json:"id"`
	Amount  float64       `json:"amount"`
	Payment PaymentMethod `json:"payment"`
}
```

### schema.go (v1 per-field interface configuration)
```go
//go:build jsonschema
// +build jsonschema

package myapp

import (
	"encoding/json"
	jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Order) Schema() json.RawMessage { panic("not implemented") }

// v1 style: Configure interface per struct field
var _ = jsonschema.NewJSONSchemaMethod(
	Order.Schema,
	// Mark the Payment field as a discriminated union
	jsonschema.WithInterface(Order{}.Payment),
	// Specify implementations
	jsonschema.WithInterfaceImpls(Order{}.Payment, 
		CreditCard{}, 
		BankTransfer{}, 
		(*PayPal)(nil),  // Use nil pointer for pointer receivers
	),
	// Custom discriminator property (default is "!type")
	jsonschema.WithDiscriminator(Order{}.Payment, "!kind"),
)
```

### Alternative: Legacy global interface registration
```go
// Legacy style (still works, but can't customize discriminator)
var (
	_ = jsonschema.NewJSONSchemaMethod(Order.Schema)
	_ = jsonschema.NewInterfaceImpl[PaymentMethod](
		CreditCard{}, 
		BankTransfer{}, 
		(*PayPal)(nil),
	)
)
```

## Complete Working Example 4: Field Schema Providers

When you need precise control over specific field schemas (e.g., for dynamic schemas):

### types.go
```go
package myapp

import "encoding/json"

type Config struct {
	Name     string          `json:"name"`
	Settings json.RawMessage `json:"settings"` // Dynamic based on Name
}

// Provider methods for custom field schemas
func (c Config) SettingsSchema() json.Marshaler {
	// Return different schema based on actual value
	switch c.Name {
	case "database":
		return jsonschema.ObjectSchema(map[string]json.Marshaler{
			"host": jsonschema.StringSchema("Database host"),
			"port": jsonschema.IntSchema("Database port"),
		}, "Database settings", true)
	case "cache":
		return jsonschema.ObjectSchema(map[string]json.Marshaler{
			"ttl": jsonschema.IntSchema("Cache TTL in seconds"),
		}, "Cache settings", true)
	default:
		return jsonschema.ObjectSchema(nil, "Custom settings", false)
	}
}
```

### schema.go
```go
//go:build jsonschema
// +build jsonschema

package myapp

import (
	"encoding/json"
	jsonschema "github.com/tylergannon/go-gen-jsonschema"
)

func (Config) Schema() json.RawMessage { panic("not implemented") }

var _ = jsonschema.NewJSONSchemaMethod(
	Config.Schema,
	// Use provider for Settings field
	jsonschema.WithStructAccessorMethod(Config{}.Settings, (Config).SettingsSchema),
)
```

This generates a template that calls your provider at runtime:
- `jsonschema/Config.json` contains `{{.settings}}` placeholder
- At runtime, Schema() method calls SettingsSchema() on the actual receiver
- The returned schema replaces the placeholder

## Key Points for Success

### 1. Build Tags Are Critical
The `//go:build jsonschema` tag isolates schema definitions from production builds.
Without it, the generator won't find your registrations.

### 2. Method Signatures Must Match
- Schema methods: `func (T) Schema() json.RawMessage`
- Provider methods must return `json.Marshaler`
- Interface implementations must implement the interface

### 3. Field Tags Control Output
- `json:"name"` - JSON field name
- `jsonschema:"optional"` - Field not required
- `jsonschema:"ref=path"` - Use $ref instead of inline
- `description:"text"` - Override doc comment

### 4. Comments Become Descriptions
Field and type doc comments automatically become JSON Schema descriptions.

### 5. Generation Process
1. Generator reads files with `jsonschema` build tag
2. Finds all NewJSONSchemaMethod/NewEnumType/etc. registrations
3. Analyzes Go types using AST
4. Generates JSON schemas in jsonschema/ directory
5. Creates jsonschema_gen.go with Schema() implementations

### 6. The Options Pattern Works
The v1 Options pattern (WithInterface, WithInterfaceImpls, WithDiscriminator, etc.) 
is functional and recommended for per-field configuration of unions and enums.

## Common Errors & Solutions

### "No packages found for open file"
Your IDE doesn't recognize the jsonschema build tag. This is normal and doesn't affect generation.

### "panic: not implemented" 
You're calling Schema() in code with the jsonschema build tag active. 
The real implementation is in jsonschema_gen.go (without the tag).

### Schema not generated
- Check build tag: `//go:build jsonschema`
- Verify registration: `var _ = jsonschema.NewJSONSchemaMethod(T.Schema)`
- Method signature: `func (T) Schema() json.RawMessage`

### Interface unions not working
- All implementations must be registered
- Use `(*PointerType)(nil)` for pointer receivers
- Can't mix legacy and v1 interface styles in same package

## Testing Your Schemas

```go
// In your test file
func TestSchema(t *testing.T) {
	person := Person{Name: "Alice", Age: 30}
	schema := person.Schema()
	
	// schema is valid JSON that can be used with OpenAI, Anthropic, etc.
	var js map[string]interface{}
	if err := json.Unmarshal(schema, &js); err != nil {
		t.Fatal(err)
	}
	
	// Use schema with your LLM client
}
```